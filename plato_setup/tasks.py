import logging
import subprocess
import os
from pathlib import Path
from typing import Optional
from colorama import Style

from .config import Config
from .process_manager import ProcessManager
from .utils import expand_classpath_wildcards, wait_for_ports
from .constants import (
    SERVER_WAIT_TIMEOUT_S,
    SERVER_WAIT_INTERVAL_S,
    SERVER_PREFIX,
    TBOARD_PREFIX,
    ROBO_PREFIX_BASE,
    COMPILER_PREFIX,
)
from .logger import log_with_prefix

log = logging.getLogger(__name__)


def generate_battle_file(
    cfg: Config, base_battle_file_path: Optional[Path] = None
) -> bool:
    """Generates a .battle file using config values, optionally based on a template."""
    output_path = cfg.get_path("generated_battle_file")
    if not output_path:
        log.error("Internal error: Generated battle file path not set in config.")
        return False

    robot_details = cfg.get_my_robot_details()
    my_robot = robot_details["full_name"]
    opponents = cfg.get_opponents_list()

    log.info(f"Generating battle file: {output_path}")
    log.info(f"My Robot: {my_robot}")
    log.info(f"Opponents: {', '.join(opponents) if opponents else 'None'}")

    all_robots = opponents + ([my_robot] if my_robot else [])
    selected_robots = sorted(list(set(filter(None, all_robots))))
    if not selected_robots:
        log.error(
            "Cannot generate battle file: No robots (neither yours nor opponents) are defined."
        )
        return False

    battle_props = {
        "robocode.battleField.width": cfg.get("robocode.battlefield_width"),
        "robocode.battleField.height": cfg.get("robocode.battlefield_height"),
        "robocode.battle.numRounds": cfg.get("robocode.num_rounds"),
        "robocode.battle.gunCoolingRate": cfg.get("robocode.gun_cooling_rate"),
        "robocode.battle.rules.inactivityTime": cfg.get("robocode.inactivity_time"),
        "robocode.battle.selectedRobots": ",".join(selected_robots),
    }
    log.info(
        f"Battle Params: W={battle_props['robocode.battleField.width']}, "
        f"H={battle_props['robocode.battleField.height']}, "
        f"Rounds={battle_props['robocode.battle.numRounds']}, "
        f"CoolRate={battle_props['robocode.battle.gunCoolingRate']}, "
        f"Inactivity={battle_props['robocode.battle.rules.inactivityTime']}"
    )
    log.info(f"Selected Robots: {battle_props['robocode.battle.selectedRobots']}")

    final_lines = []
    existing_keys = set()

    if base_battle_file_path and base_battle_file_path.is_file():
        log.info(f"Using base battle file: {base_battle_file_path}")
        try:
            with open(base_battle_file_path, "r") as f_base:
                for line in f_base:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        final_lines.append(line)
                        continue
                    if "=" in line:
                        key = line.split("=", 1)[0].strip()
                        if key in battle_props:
                            final_lines.append(f"{key}={battle_props[key]}")
                            existing_keys.add(key)
                        else:
                            final_lines.append(line)
                            existing_keys.add(key)
                    else:
                        final_lines.append(line)
        except Exception as e:
            log.error(f"Error reading base battle file {base_battle_file_path}: {e}")
            return False
    else:
        if base_battle_file_path:
            log.warning(
                f"Base battle file not found at {base_battle_file_path}. Generating from scratch."
            )
        else:
            log.info("No base battle file specified. Generating from scratch.")
        final_lines.append(
            f"# Robocode Battle Specification generated by {cfg.project_root.name}/{__package__}"
        )

    for key, value in battle_props.items():
        if key not in existing_keys:
            final_lines.append(f"{key}={value}")

    try:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w") as f_out:
            for line in final_lines:
                f_out.write(line + "\n")
        log.info("Battle file generated successfully.")
        return True
    except Exception as e:
        log.error(f"Failed to write generated battle file {output_path}: {e}")
        return False


def compile_robot(cfg: Config) -> bool:
    """Compiles the Java robot source files."""
    log.info("Compiling Robocode robot...")
    robot_details = cfg.get_my_robot_details()
    robot_src_dir = cfg.get_path("robot_src_dir")
    robot_bin_dir = cfg.get_path("robot_bin_dir")
    robot_libs_dir = cfg.get_path("robot_libs_dir")
    project_libs_dir = cfg.get_path("project_libs_dir")
    robocode_home = cfg.get_path("robocode_home")

    if not robot_src_dir or not robot_bin_dir or not robocode_home:
        log.error(
            "Missing critical path configurations (robot src/bin, robocode home)."
        )
        return False

    if not robot_src_dir.is_dir():
        log.error(f"Robot source directory not found: {robot_src_dir}")
        return False

    java_files = list(robot_src_dir.rglob("*.java"))
    if not java_files:
        log.error(f"No *.java files found in source directory: {robot_src_dir}")
        return False
    log.info(f"Found {len(java_files)} Java source file(s).")

    cp_parts = []
    if robot_libs_dir.is_dir():
        cp_parts.append(str(robot_libs_dir / "*"))
    if robocode_home.is_dir():
        cp_parts.append(str(robocode_home / "libs" / "*"))
    if project_libs_dir.is_dir() and any(project_libs_dir.iterdir()):
        cp_parts.append(str(project_libs_dir / "*"))

    compile_classpath = expand_classpath_wildcards(cp_parts)

    try:
        robot_bin_dir.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        log.error(f"Failed to create robot bin directory {robot_bin_dir}: {e}")
        return False

    javac_cmd = [
        "javac",
        "-Xlint:deprecation",
        "-Xlint:unchecked",
        "-sourcepath",
        str(robot_src_dir.resolve()),
        "-cp",
        compile_classpath,
        "-d",
        str(robot_bin_dir.resolve()),
    ]
    javac_cmd.extend([str(f.resolve()) for f in java_files])

    log.debug(f"Compiler Classpath (first 200 chars): {compile_classpath[:200]}...")
    log.debug(
        f"Compile Command: {' '.join(javac_cmd[:6])} ... ({len(java_files)} files)"
    )

    try:
        log.info("Running javac...")
        process = subprocess.Popen(
            javac_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding="utf-8",
            errors="replace",
        )

        if process.stdout:
            for line in iter(process.stdout.readline, ""):
                log_with_prefix(logging.INFO, COMPILER_PREFIX, line.strip())
            process.stdout.close()

        return_code = process.wait()

        if return_code != 0:
            log.error(f"Robot compilation failed with exit code {return_code}.")
            return False
        else:
            log.info("Robot compilation successful.")

            expected_class_rel_path = (
                Path(robot_details["package_path"]) / robot_details["class_file"]
            )
            expected_class_file = robot_bin_dir / expected_class_rel_path
            log.debug(f"Verifying class file existence at: {expected_class_file}")
            if not expected_class_file.is_file():
                log.error(
                    f"Compiled class file not found after successful compile: {expected_class_file}"
                )
                log.error(
                    f"Check package structure in '{robot_src_dir}' matches robot name '{robot_details['full_name']}'."
                )
                log.error(
                    f"Expected: '{expected_class_rel_path}' inside '{robot_bin_dir}'"
                )
                try:
                    log.info(f"Contents of {robot_bin_dir}:")
                    for item in robot_bin_dir.rglob("*"):
                        log.info(f"  - {item.relative_to(robot_bin_dir)}")
                except Exception as list_e:
                    log.warning(f"Could not list contents of {robot_bin_dir}: {list_e}")
                return False
            else:
                log.info(
                    f"Verified class file exists: {expected_class_file.relative_to(cfg.project_root)}"
                )
                return True

    except FileNotFoundError:
        log.error("`javac` command not found. Is JDK installed and in PATH?")
        return False
    except Exception as e:
        log.error(f"An error occurred during compilation: {e}", exc_info=True)
        return False


def check_robot_compiled(cfg: Config) -> bool:
    """Checks if the main robot class file exists in the bin directory."""
    robot_details = cfg.get_my_robot_details()
    robot_bin_dir = cfg.get_path("robot_bin_dir")
    if not robot_bin_dir:
        return False

    expected_class_rel_path = (
        Path(robot_details["package_path"]) / robot_details["class_file"]
    )
    expected_class_file = robot_bin_dir / expected_class_rel_path

    if expected_class_file.is_file():
        log.debug(f"Found pre-compiled robot class file: {expected_class_file}")
        return True
    else:
        log.debug(f"Pre-compiled robot class file not found: {expected_class_file}")
        return False


def start_tensorboard(cfg: Config, pm: ProcessManager) -> bool:
    """Starts the TensorBoard process."""
    log_dir = cfg.get_path("log_dir")
    if not log_dir:
        return False
    tensorboard_log = log_dir / "tensorboard.log"

    cmd = ["tensorboard", f"--logdir={log_dir.resolve()}"]
    if cfg.get("tensorboard.bind_all", False):
        cmd.append("--bind_all")

    return pm.start_process(
        name="tensorboard",
        cmd=cmd,
        cwd=cfg.project_root,
        log_path=tensorboard_log,
        log_prefix=TBOARD_PREFIX,
    )


def start_server(cfg: Config, pm: ProcessManager) -> bool:
    """Starts the Python RL server process."""
    server_dir = cfg.get_path("server_dir")
    log_dir = cfg.get_path("log_dir")
    if not server_dir or not log_dir:
        return False
    server_log = log_dir / "server.log"

    python_exe = cfg.get("server.python_exe_resolved")
    server_script = cfg.get_server_script_path()

    if not server_script.is_file():
        log.error(f"Server script not found: {server_script}")
        return False

    cmd = [
        python_exe,
        str(server_script),
        "--ip",
        cfg.get("server.ip"),
        "--learn-port",
        str(cfg.get("server.learn_port")),
        "--weight-port",
        str(cfg.get("server.weight_port")),
        "--log-dir",
        str(log_dir.resolve()),
        "--log-level",
        cfg.get("logging.python_log_level", "INFO"),
    ]

    env = os.environ.copy()
    env["TF_CPP_MIN_LOG_LEVEL"] = "2"

    log.debug(f"Starting server with command: {' '.join(cmd)}")
    log.debug(f"Server CWD: {server_dir}")

    os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"

    started = pm.start_process(
        name="server",
        cmd=cmd,
        cwd=server_dir,
        log_path=server_log,
        log_prefix=SERVER_PREFIX,
    )
    return started


def wait_for_server_ports(cfg: Config) -> bool:
    """Waits for the server's TCP and UDP ports to become available."""
    ip = cfg.get("server.ip")
    tcp_port = cfg.get("server.weight_port")
    udp_port = cfg.get("server.learn_port")

    return wait_for_ports(
        host=ip,
        tcp_ports=[tcp_port],
        udp_ports=[udp_port],
        timeout=SERVER_WAIT_TIMEOUT_S,
        interval=SERVER_WAIT_INTERVAL_S,
    )


def start_robocode_instance(instance_id: int, cfg: Config, pm: ProcessManager) -> bool:
    """Starts a single Robocode instance."""
    instance_name = f"robocode_{instance_id}"
    log_dir = cfg.get_path("log_dir")
    if not log_dir:
        return False
    instance_log = log_dir / f"{instance_name}.log"

    robocode_home = cfg.get_path("robocode_home")
    robot_bin_dir = cfg.get_path("robot_bin_dir")
    robot_libs_dir = cfg.get_path("robot_libs_dir")
    project_libs_dir = cfg.get_path("project_libs_dir")
    battle_file = cfg.get_path("generated_battle_file")

    if not all([robocode_home, robot_bin_dir, battle_file]):
        log.error(f"Missing required paths for Robocode instance {instance_id}.")
        return False
    if not battle_file.is_file():
        log.error(
            f"Generated battle file not found for Robocode instance {instance_id}: {battle_file}"
        )
        return False
    if not robot_bin_dir.is_dir():
        log.error(
            f"Robot bin directory not found for Robocode instance {instance_id}: {robot_bin_dir}"
        )
        return False

    cp_parts = [str(robot_bin_dir.resolve())]
    if robot_libs_dir.is_dir():
        cp_parts.append(str(robot_libs_dir / "*"))
    if robocode_home.is_dir():
        cp_parts.append(str(robocode_home / "libs" / "*"))
    if project_libs_dir.is_dir() and any(project_libs_dir.iterdir()):
        cp_parts.append(str(project_libs_dir / "*"))

    robocode_classpath = expand_classpath_wildcards(cp_parts)

    robocode_cmd = [
        "java",
        "-Xmx512M",
        "--add-opens",
        "java.base/sun.net.www.protocol.jar=ALL-UNNAMED",
        "--add-exports",
        "java.desktop/sun.awt=ALL-UNNAMED",
        "-Dsun.io.useCanonCaches=false",
        "-Ddebug=true",
        "-DNOSECURITY=true",
        f"-Drobocode.home={robocode_home.resolve()}",
        f"-Drobocode.development.path={robot_bin_dir.resolve()}",
        "-Dfile.encoding=UTF-8",
        "-cp",
        robocode_classpath,
        "robocode.Robocode",
        "-battle",
        str(battle_file.resolve()),
        "-tps",
        str(cfg.get("robocode.tps")),
    ]

    if not cfg.get("robocode.gui", False):
        robocode_cmd.append("-nodisplay")
    else:
        log.info(f"Robocode instance {instance_id} running WITH GUI.")

    robo_prefix = f"{ROBO_PREFIX_BASE}{instance_id}]{Style.RESET_ALL}"

    return pm.start_process(
        name=instance_name,
        cmd=robocode_cmd,
        cwd=robocode_home,
        log_path=instance_log,
        log_prefix=robo_prefix,
    )
