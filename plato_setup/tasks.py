import logging
import os
import subprocess
from pathlib import Path
from typing import Optional, List

from colorama import Style

from .config import Config
from .constants import (
    MAVEN_PREFIX,
    ROBO_PREFIX_BASE,
    SERVER_PREFIX,
    SERVER_WAIT_INTERVAL_S,
    SERVER_WAIT_TIMEOUT_S,
    TBOARD_PREFIX,
)
from .logger import log_with_prefix
from .process_manager import ProcessManager
from .utils import (
    expand_classpath_wildcards,
    wait_for_ports,
)

log = logging.getLogger(__name__)


def generate_battle_file(
    cfg: Config, base_battle_file_path: Optional[Path] = None
) -> bool:
    """Generates a .battle file using config values, optionally based on a template."""
    output_path = cfg.get_path("generated_battle_file")
    if not output_path:
        log.error("Internal error: Generated battle file path not set in config.")
        return False

    robot_details = cfg.get_my_robot_details()
    my_robot = robot_details["full_name"]
    opponents = cfg.get_opponents_list()

    log.info(f"Generating battle file: {output_path}")
    log.info(f"My Robot: {my_robot}")
    log.info(f"Opponents: {', '.join(opponents) if opponents else 'None'}")

    all_robots = opponents + ([my_robot] if my_robot else [])
    selected_robots = sorted(list(set(filter(None, all_robots))))
    if not selected_robots:
        log.error(
            "Cannot generate battle file: No robots (neither yours nor opponents) are defined."
        )
        return False

    battle_props = {
        "robocode.battleField.width": cfg.get("robocode.battlefield_width"),
        "robocode.battleField.height": cfg.get("robocode.battlefield_height"),
        "robocode.battle.numRounds": cfg.get("robocode.num_rounds"),
        "robocode.battle.gunCoolingRate": cfg.get("robocode.gun_cooling_rate"),
        "robocode.battle.rules.inactivityTime": cfg.get("robocode.inactivity_time"),
        "robocode.battle.selectedRobots": ",".join(selected_robots),
    }
    log.info(
        f"Battle Params: W={battle_props['robocode.battleField.width']}, "
        f"H={battle_props['robocode.battleField.height']}, "
        f"Rounds={battle_props['robocode.battle.numRounds']}, "
        f"CoolRate={battle_props['robocode.battle.gunCoolingRate']}, "
        f"Inactivity={battle_props['robocode.battle.rules.inactivityTime']}"
    )
    log.info(f"Selected Robots: {battle_props['robocode.battle.selectedRobots']}")

    final_lines = []
    existing_keys = set()

    if base_battle_file_path and base_battle_file_path.is_file():
        log.info(f"Using base battle file: {base_battle_file_path}")
        try:
            with open(base_battle_file_path, "r") as f_base:
                for line in f_base:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        final_lines.append(line)
                        continue
                    if "=" in line:
                        key = line.split("=", 1)[0].strip()
                        if key in battle_props:
                            final_lines.append(f"{key}={battle_props[key]}")
                            existing_keys.add(key)
                        else:
                            final_lines.append(line)
                            existing_keys.add(key)
                    else:
                        final_lines.append(line)
        except Exception as e:
            log.error(f"Error reading base battle file {base_battle_file_path}: {e}")
            return False
    else:
        if base_battle_file_path:
            log.warning(
                f"Base battle file not found at {base_battle_file_path}. Generating from scratch."
            )
        else:
            log.info("No base battle file specified. Generating from scratch.")
        final_lines.append("# Robocode Battle Specification generated by plato_setup")

    for key, value in battle_props.items():
        if key not in existing_keys:
            final_lines.append(f"{key}={value}")

    try:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w") as f_out:
            for line in final_lines:
                f_out.write(line + "\n")
        log.info("Battle file generated successfully.")
        return True
    except Exception as e:
        log.error(f"Failed to write generated battle file {output_path}: {e}")
        return False


def compile_robot(cfg: Config) -> bool:
    """Compiles the Java robot using Maven."""
    log.info("Compiling Robocode robot using Maven...")
    maven_project_dir = cfg.get_path("maven_project_dir")
    if not maven_project_dir or not maven_project_dir.is_dir():
        log.error(
            f"Maven project directory not configured or found: {maven_project_dir}"
        )
        return False
    pom_file = maven_project_dir / "pom.xml"
    if not pom_file.is_file():
        log.error(f"pom.xml not found in Maven project directory: {pom_file}")
        return False

    robocode_home_path = cfg.get_path("robocode_home")
    if not robocode_home_path or not robocode_home_path.is_dir():
        log.error(f"Robocode home path not configured or invalid: {robocode_home_path}")
        return False

    mvn_cmd = [
        "mvn",
        "clean",
        "package",
        f"-Drobocode.home={robocode_home_path.resolve()}",
        "-f",
        str(pom_file.resolve()),
    ]

    log.debug(f"Maven Compile Command: {' '.join(mvn_cmd)}")
    log.debug(f"Maven Working Directory: {maven_project_dir}")

    try:
        log.info("Running Maven build...")
        process = subprocess.Popen(
            mvn_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding="utf-8",
            errors="replace",
            cwd=maven_project_dir,
        )

        if process.stdout:
            for line in iter(process.stdout.readline, ""):
                log_with_prefix(logging.INFO, MAVEN_PREFIX, line.strip())
            process.stdout.close()

        return_code = process.wait()

        if return_code != 0:
            log.error(f"Maven build failed with exit code {return_code}.")
            log.error("Check the Maven output above for details.")
            return False
        else:
            log.info("Maven build successful.")

            artifact_id = cfg.get("maven.artifact_id", "plato-robot")
            version = cfg.get("maven.version", "1.0-SNAPSHOT")
            target_dir = maven_project_dir / "target"
            expected_jar_file = target_dir / f"{artifact_id}-{version}.jar"
            dep_dir = target_dir / "lib"

            if not expected_jar_file.is_file():
                log.error(
                    f"Expected robot JAR file not found after build: {expected_jar_file}"
                )
                log.error(
                    "Check pom.xml <artifactId> and <version> match expectations."
                )
                return False
            log.info(
                f"Verified robot JAR exists: {expected_jar_file.relative_to(cfg.project_root)}"
            )

            if not dep_dir.is_dir():
                log.warning(
                    f"Maven dependency directory not found: {dep_dir}. Dependencies might be missing."
                )
                return False
            elif not any(dep_dir.glob("*.jar")):
                log.warning(
                    f"Maven dependency directory {dep_dir} exists but contains no JAR files."
                )

            return True

    except FileNotFoundError:
        log.error(
            "`mvn` command not found. Is Apache Maven installed and in your system PATH?"
        )
        return False
    except Exception as e:
        log.error(f"An error occurred during Maven build: {e}", exc_info=True)
        return False


def check_robot_compiled(cfg: Config) -> bool:
    """Checks if the Maven-built robot JAR and dependency dir exist."""
    maven_project_dir = cfg.get_path("maven_project_dir")
    if not maven_project_dir or not maven_project_dir.is_dir():
        log.debug("Maven project directory not configured or not found.")
        return False

    artifact_id = cfg.get("maven.artifact_id", "plato-robot")
    version = cfg.get("maven.version", "1.0-SNAPSHOT")
    target_dir = maven_project_dir / "target"
    expected_jar_file = target_dir / f"{artifact_id}-{version}.jar"
    dep_dir = target_dir / "lib"

    jar_exists = expected_jar_file.is_file()
    deps_exist = dep_dir.is_dir() and any(dep_dir.glob("*.jar"))

    if jar_exists and deps_exist:
        log.debug(f"Found Maven-built robot JAR: {expected_jar_file}")
        log.debug(f"Found Maven dependency JARs in: {dep_dir}")
        return True
    else:
        if not jar_exists:
            log.debug(f"Maven-built robot JAR not found: {expected_jar_file}")
        if not deps_exist:
            log.debug(f"Maven dependency directory/JARs not found or empty: {dep_dir}")
        return False


def start_tensorboard(cfg: Config, pm: ProcessManager) -> bool:
    """Starts the TensorBoard process."""
    log_dir = cfg.get_path("log_dir")
    if not log_dir:
        log.error("Log directory path not found for TensorBoard.")
        return False
    tensorboard_log = log_dir / "tensorboard.log"

    cmd = ["tensorboard", f"--logdir={log_dir.resolve()}"]
    if cfg.get("tensorboard.bind_all", False):
        cmd.append("--bind_all")
    else:
        cmd.append("--host=localhost")

    return pm.start_process(
        name="tensorboard",
        cmd=cmd,
        cwd=cfg.project_root,
        log_path=tensorboard_log,
        log_prefix=TBOARD_PREFIX,
    )


def start_server(cfg: Config, pm: ProcessManager) -> bool:
    """Starts the Python RL server process."""
    server_dir = cfg.get_path("server_dir")
    log_dir = cfg.get_path("log_dir")
    if not server_dir or not log_dir:
        log.error("Server directory or log directory path not found.")
        return False
    server_log = log_dir / "server.log"

    python_exe = cfg.get("server.python_exe_resolved")
    server_script = cfg.get_server_script_path()

    if not python_exe:
        log.error("Python executable path was not resolved.")
        return False
    if not server_script.is_file():
        log.error(f"Server script not found: {server_script}")
        return False

    cmd = [
        python_exe,
        str(server_script),
        "--ip",
        cfg.get("server.ip"),
        "--learn-port",
        str(cfg.get("server.learn_port")),
        "--weight-port",
        str(cfg.get("server.weight_port")),
        "--log-dir",
        str(log_dir.resolve()),
        "--log-level",
        cfg.get("logging.python_log_level", "INFO"),
    ]

    env = os.environ.copy()
    env["TF_CPP_MIN_LOG_LEVEL"] = "2"

    log.debug(f"Starting server with command: {' '.join(cmd)}")
    log.debug(f"Server CWD: {server_dir}")

    started = pm.start_process(
        name="server",
        cmd=cmd,
        cwd=server_dir,
        log_path=server_log,
        log_prefix=SERVER_PREFIX,
        env=env,
    )
    return started


def wait_for_server_ports(cfg: Config) -> bool:
    """Waits for the server's TCP and UDP ports to become available."""
    ip = cfg.get("server.ip")
    tcp_port = cfg.get("server.weight_port")
    udp_port = cfg.get("server.learn_port")

    return wait_for_ports(
        host=ip,
        tcp_ports=[tcp_port],
        udp_ports=[udp_port],
        timeout=SERVER_WAIT_TIMEOUT_S,
        interval=SERVER_WAIT_INTERVAL_S,
    )


def start_robocode_instance(instance_id: int, cfg: Config, pm: ProcessManager) -> bool:
    """Starts a single Robocode instance using Maven build artifacts."""
    instance_name = f"robocode_{instance_id}"
    log_dir = cfg.get_path("log_dir")
    if not log_dir:
        log.error(f"Log directory path not found for Robocode instance {instance_id}.")
        return False
    instance_log = log_dir / f"{instance_name}.log"

    robocode_home = cfg.get_path("robocode_home")
    maven_project_dir = cfg.get_path("maven_project_dir")
    battle_file = cfg.get_path("generated_battle_file")

    if not all([robocode_home, maven_project_dir, battle_file]):
        log.error(
            f"Missing required paths (Robocode home, Maven dir, or Battle file) for Robocode instance {instance_id}."
        )
        return False
    if not robocode_home.is_dir():
        log.error(f"Robocode home directory not found: {robocode_home}")
        return False
    if not maven_project_dir.is_dir():
        log.error(f"Maven project directory not found: {maven_project_dir}")
        return False
    if not battle_file.is_file():
        log.error(f"Generated battle file not found: {battle_file}")
        return False

    cp_parts: List[str] = []

    robocode_libs_dir = robocode_home / "libs"
    if robocode_libs_dir.is_dir():
        cp_parts.append(str(robocode_libs_dir.resolve() / "*"))
        log.debug(f"Adding Robocode libs path: {robocode_libs_dir.resolve() / '*'}")
    else:
        log.warning(
            f"Robocode libs directory not found: {robocode_libs_dir}. Classpath may be incomplete."
        )

    artifact_id = cfg.get("maven.artifact_id", "plato-robot")
    version = cfg.get("maven.version", "1.0-SNAPSHOT")
    target_dir = maven_project_dir / "target"
    robot_jar = target_dir / f"{artifact_id}-{version}.jar"
    if robot_jar.is_file():
        cp_parts.append(str(robot_jar.resolve()))
        log.debug(f"Adding robot JAR to classpath: {robot_jar.resolve()}")
    else:
        log.error(
            f"Robot JAR not found: {robot_jar}. Ensure Maven build was successful before starting Robocode."
        )
        return False

    dependency_lib_dir = target_dir / "lib"
    if dependency_lib_dir.is_dir() and any(dependency_lib_dir.glob("*.jar")):
        cp_parts.append(str(dependency_lib_dir.resolve() / "*"))
        log.debug(f"Adding dependency libs path: {dependency_lib_dir.resolve() / '*'}")
    else:
        log.warning(
            f"Maven dependency directory ({dependency_lib_dir}) not found or empty. Runtime dependencies might be missing."
        )

    robocode_classpath = expand_classpath_wildcards(cp_parts)
    if not robocode_classpath:
        log.error(
            "Failed to construct Robocode classpath. expand_classpath_wildcards returned empty."
        )
        return False

    log.debug(f"Instance {instance_id} Classpath Length: {len(robocode_classpath)}")
    log.debug(
        f"Instance {instance_id} Classpath (first 300 chars): {robocode_classpath[:300]}..."
    )

    robocode_cmd = [
        "java",
        "-Xmx512M",
        "--add-opens",
        "java.base/sun.net.www.protocol.jar=ALL-UNNAMED",
        "--add-exports",
        "java.desktop/sun.awt=ALL-UNNAMED",
        "-Dsun.io.useCanonCaches=false",
        "-Ddebug=true",
        "-DNOSECURITY=true",
        f"-Drobocode.home={robocode_home.resolve()}",
        "-Dfile.encoding=UTF-8",
        "-cp",
        robocode_classpath,
        "robocode.Robocode",
        "-battle",
        str(battle_file.resolve()),
        "-tps",
        str(cfg.get("robocode.tps")),
    ]

    if not cfg.get("robocode.gui", False):
        robocode_cmd.append("-nodisplay")
        log.info(f"Starting Robocode instance {instance_id} WITHOUT GUI.")
    else:
        log.info(f"Starting Robocode instance {instance_id} WITH GUI.")

    robo_prefix = f"{ROBO_PREFIX_BASE}{instance_id}]{Style.RESET_ALL}"

    return pm.start_process(
        name=instance_name,
        cmd=robocode_cmd,
        cwd=robocode_home,
        log_path=instance_log,
        log_prefix=robo_prefix,
    )
