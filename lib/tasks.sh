#!/bin/bash

# Depends on global config variables (ROBOCODE_HOME, LOG_DIR, etc.)
# Depends on global derived variables (ROBOT_BIN_DIR, etc.)
# Depends on global flags (FLAG_COMPILE_ROBOT)
# Depends on global PID variables (SERVER_PID, ROBOCODE_PIDS etc.)

generate_battle_file() {
  local battle_file_path="$1"

  # Use global battle parameters: ROBOCODE_BATTLEFIELD_WIDTH, ROBOCODE_BATTLEFIELD_HEIGHT,
  # ROBOCODE_NUM_ROUNDS, ROBOCODE_GUN_COOLING_RATE, ROBOCODE_INACTIVITY_TIME
  read -r -a opponent_array <<<"$ROBOCODE_OPPONENTS"

  log_info "Generating battle file: ${battle_file_path}"
  log_info "My Robot: ${ROBOCODE_MY_ROBOT_NAME}"
  log_info "Opponents: ${ROBOCODE_OPPONENTS}"
  log_info "Battle Params: ${ROBOCODE_BATTLEFIELD_WIDTH}x${ROBOCODE_BATTLEFIELD_HEIGHT}, ${ROBOCODE_NUM_ROUNDS} Rnds, CoolRate ${ROBOCODE_GUN_COOLING_RATE}, Inactivity ${ROBOCODE_INACTIVITY_TIME}"

  if [ -z "$ROBOCODE_MY_ROBOT_NAME" ]; then
    log_error "ROBOCODE_MY_ROBOT_NAME is not set."
    return 1
  fi

  cat >"${battle_file_path}" <<EOF
# Robocode Battle Specification generated by ${SCRIPT_NAME}

# Battle Field
robocode.battleField.width=${ROBOCODE_BATTLEFIELD_WIDTH}
robocode.battleField.height=${ROBOCODE_BATTLEFIELD_HEIGHT}

# Battle Rules
robocode.battle.numRounds=${ROBOCODE_NUM_ROUNDS}
robocode.battle.gunCoolingRate=${ROBOCODE_GUN_COOLING_RATE}
robocode.battle.rules.inactivityTime=${ROBOCODE_INACTIVITY_TIME}

# Robots
EOF
  local opponent_list
  opponent_list=$(printf ",%s" "${opponent_array[@]}")
  opponent_list=${opponent_list:1}

  local robots_line="${ROBOCODE_MY_ROBOT_NAME}"
  if [[ -n "$opponent_list" ]]; then
    robots_line="${opponent_list},${robots_line}"
  else
    log_warn "No opponents specified! Battle will include only ${ROBOCODE_MY_ROBOT_NAME}."
  fi
  echo "robocode.battle.selectedRobots=${robots_line}" >>"${battle_file_path}"

  log_info "Battle file generated successfully."
  return 0
}

compile_robot() {
  local expected_path_part=""
  if [[ -n "$MY_ROBOT_PACKAGE_PATH" ]]; then expected_path_part="${MY_ROBOT_PACKAGE_PATH}/"; fi
  local expected_file_raw="${ROBOT_BIN_DIR}/${expected_path_part}${MY_ROBOT_CLASS_FILE}"
  local expected_file_normalized=$(echo "${expected_file_raw}" | tr -s '/')

  if ! ${FLAG_COMPILE_ROBOT}; then
    log_info "Skipping robot compilation (--no-compile)."
    if [ ! -d "${ROBOT_BIN_DIR}" ]; then
      log_error "Robot bin directory missing: ${ROBOT_BIN_DIR}"
      return 1
    fi
    if [ ! -f "${expected_file_normalized}" ]; then
      log_error "Required robot class file missing: ${expected_file_normalized}"
      return 1
    fi
    log_info "Pre-compiled robot class file found."
    return 0
  fi

  log_info "Compiling Robocode robot: ${ROBOCODE_MY_ROBOT_NAME}"
  local path_sep=":"
  local javac_opts="-Xlint:deprecation -Xlint:unchecked"
  local compile_cp_parts=("${ROBOT_LIBS_DIR}/*" "${ROBOCODE_HOME}/libs/*")
  if [[ -d "${PROJECT_LIBS_DIR}" && "$(ls -A ${PROJECT_LIBS_DIR})" ]]; then compile_cp_parts+=("${PROJECT_LIBS_DIR}/*"); fi
  local compile_classpath=$(
    IFS=$path_sep
    echo "${compile_cp_parts[*]}"
  )

  mkdir -p "${ROBOT_BIN_DIR}"
  log_debug "Compile CP Length: ${#compile_classpath}"
  log_debug "Source Dir: ${ROBOT_SRC_DIR}, Output Dir: ${ROBOT_BIN_DIR}"

  if ! find "${ROBOT_SRC_DIR}" -name '*.java' -print0 | xargs -0 javac -cp "${compile_classpath}" ${javac_opts} -d "${ROBOT_BIN_DIR}"; then
    log_error "Robot compilation failed."
    return 1
  fi

  log_debug "Checking for compiled file at normalized path: ${expected_file_normalized}"
  log_debug "(Raw components: BIN='${ROBOT_BIN_DIR}', PKG='${MY_ROBOT_PACKAGE_PATH}', CLASS='${MY_ROBOT_CLASS_FILE}')"

  if [ ! -f "${expected_file_normalized}" ]; then
    log_error "Compiled class file not found after compile: ${expected_file_normalized}"
    log_error "Check ROBOT_BIN_DIR ('${ROBOT_BIN_DIR}') contents and package structure matches '${ROBOCODE_MY_ROBOT_NAME}'."
    log_info "Listing contents of ROBOT_BIN_DIR:"
    ls -lR "${ROBOT_BIN_DIR}" || log_warn "Could not list ${ROBOT_BIN_DIR}"
    return 1
  fi
  log_info "Compilation complete and class file verified."
  return 0
}

start_server() {
  log_info "Starting Python server (Log: ${SERVER_LOG})..."
  cd "${SERVER_DIR}" || {
    log_error "Server directory not found: ${SERVER_DIR}"
    return 1
  }
  export TF_CPP_MIN_LOG_LEVEL='2'
  log_debug "Python: ${SERVER_PYTHON_EXE}, Script: ${SERVER_SCRIPT_NAME}, Level: ${LOGGING_PYTHON_LOG_LEVEL}"

  "${SERVER_PYTHON_EXE}" "${SERVER_SCRIPT_NAME}" \
    --ip "${SERVER_IP}" --learn-port "${SERVER_LEARN_PORT}" --weight-port "${SERVER_WEIGHT_PORT}" \
    --log-dir "${LOG_DIR}" --log-level "${LOGGING_PYTHON_LOG_LEVEL}" &>"${SERVER_LOG}" &

  SERVER_PID=$!
  cd "${PROJECT_ROOT}" || {
    log_error "Failed to cd back to project root ${PROJECT_ROOT}"
    return 1
  }
  sleep 2
  if ! ps -p $SERVER_PID >/dev/null; then
    log_error "Python server (PID ${SERVER_PID:-N/A}) failed. Check ${SERVER_LOG}"
    SERVER_PID=""
    return 1
  fi
  log_info "Python server started (PID: ${SERVER_PID})."
  return 0
}

wait_for_server() {
  local ip=$SERVER_IP
  local learn_p=$SERVER_LEARN_PORT
  local weight_p=$SERVER_WEIGHT_PORT
  local max_wait=60
  local interval=2
  local waited=0
  log_warn "Waiting up to ${max_wait}s for server ports (UDP:${learn_p}, TCP:${weight_p}) on ${ip}..."
  while true; do
    local tcp_ok=1
    nc -z "${ip}" "${weight_p}" &>/dev/null && tcp_ok=$?
    local udp_ok=1
    nc -z -u -w 1 "${ip}" "${learn_p}" &>/dev/null && udp_ok=$?
    if [ $tcp_ok -eq 0 ] && [ $udp_ok -eq 0 ]; then
      log_info "Server ports ready."
      return 0
    fi
    if [ $waited -ge $max_wait ]; then
      log_error "Timeout waiting for server ports."
      log_error "TCP:${weight_p} status:${tcp_ok}"
      log_error "UDP:${learn_p} status:${udp_ok}"
      log_error "Check server log: ${SERVER_LOG}"
      return 1
    fi
    sleep "${interval}"
    waited=$((waited + interval))
    if ((waited % (interval * 5) == 0)); then log_warn "Still waiting... (${waited}s)"; fi
  done
}

start_robocode_instance() {
  local instance_id=$1
  local instance_log="${LOG_DIR}/robocode_${instance_id}.log"
  log_info "Starting Robocode instance ${instance_id} (Log: ${instance_log})..."
  local path_sep=":"
  local robocode_robot_path="${ROBOCODE_HOME}/robots"
  if [ ! -d "${ROBOT_BIN_DIR}" ]; then
    log_error "Robot bin dir (${ROBOT_BIN_DIR}) missing."
    return 1
  fi

  local cp_parts=("${ROBOT_BIN_DIR}" "${ROBOT_LIBS_DIR}/*" "${ROBOCODE_HOME}/libs/*")
  if [[ -d "${PROJECT_LIBS_DIR}" && "$(ls -A ${PROJECT_LIBS_DIR})" ]]; then cp_parts+=("${PROJECT_LIBS_DIR}/*"); fi
  local robocode_classpath=$(
    IFS=$path_sep
    echo "${cp_parts[*]}"
  )
  local current_battle_file="${GENERATED_BATTLE_FILE_PATH}"
  if [ ! -f "${current_battle_file}" ]; then
    log_error "Generated battle file not found: ${current_battle_file}"
    return 1
  fi

  local robocode_cmd=(java -Xmx512M
    --add-opens java.base/sun.net.www.protocol.jar=ALL-UNNAMED --add-exports java.desktop/sun.awt=ALL-UNNAMED
    -Dsun.io.useCanonCaches=false -Ddebug=true -DNOSECURITY=true -Drobocode.home="${ROBOCODE_HOME}"
    -DROBOTPATH="${robocode_robot_path}" -Drobocode.development.path="${ROBOT_BIN_DIR}" -Dfile.encoding=UTF-8
    -cp "${robocode_classpath}" robocode.Robocode -battle "${current_battle_file}" -tps "${ROBOCODE_TPS}")
  if [ "${ROBOCODE_GUI}" = "false" ]; then robocode_cmd+=("-nodisplay"); else log_info "Instance ${instance_id} running WITH GUI."; fi

  "${robocode_cmd[@]}" &>"${instance_log}" &
  local pid=$!
  ROBOCODE_PIDS+=("$pid")
  sleep 0.5
  if ! ps -p $pid >/dev/null; then
    log_error "Robocode instance ${instance_id} (PID ${pid:-N/A}) failed. Check ${instance_log}"
    return 1
  else
    log_info "Robocode instance ${instance_id} started (PID: ${pid})."
    return 0
  fi
}

tail_log() {
  local log_file="$1"
  local prefix="$2"
  if ! ${FLAG_TAIL_LOGS}; then return 0; fi
  tail -F --pid=$$ --retry "$log_file" 2>/dev/null | while IFS= read -r line; do if [[ -n "${line// /}" ]]; then echo -e "${prefix} ${line}"; fi; done &
  LOG_TAIL_PIDS+=("$!")
}
